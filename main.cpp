/********************************************
 * FILE NAME: main.cpp                      *
 * DESCRIPTION: main function for our coral *
 *              identification algorithm    *
 * AUTHORS: Diego Peña, Victor García,      *
 *          Fabio Morales, Andreina Duarte  *
 ********************************************/

#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>
#include "histogram.h"
#include "filters.h"
#include "svm.h"
#include "image.h"
#include <tuple>
#include "./args/args.hxx"
#define Malloc(type,n) (type *)malloc((n)*sizeof(type))

std::istream& operator>>(std::istream& is, std::tuple<int, int, int>& ints){
    is >> std::get<0>(ints);
    is.get();
    is >> std::get<1>(ints);
    is.get();
    is >> std::get<2>(ints);
    return is;
}

int main(int argc, char **argv){
    bool arg_svm = false;
    int n_images, i, j, k, n;
    int start_index, finish_index;
    struct img_data* descriptors;
    struct img_dataHistogram* descriptorsH;
    cv::Mat* imgs_MR;

    const int years[3] = {2008, 2009, 2010};
    int n_imgs[] = {_nImg_2008,  _nImg_2009,  _nImg_2010};
    bool valid_sets[] = {false,false, false};

    std::string loadfile, savefile;
    std::vector<std::string> file_names;

    // Argument Parser flags
    args::ArgumentParser parser("[EC5803] Coral Identification", "Authors: Diego Peña, Victor Garcia, Fabio Morales, Andreina Duarte");
    
    args::Group p(parser, "", args::Group::Validators::DontCare);
    args::HelpFlag help(p, "help", "Display this help menu", {'h', "help"});
    args::Group imgproc(p, "IMAGE PROCESSING COMMANDS");
    args::Flag descriptor(imgproc, "descriptor", "Get the descriptor for the labeled images. Use the -s command to change the default binary filename.(\"descriptor.bin\")", {"descriptor"});
    args::Flag dictionary(imgproc, "dictionary", "Get the Dictionary of textons. By default the descriptor will be calculated for this step. to use an existing \
                                       descriptor file use the -l argument. Use the -s argument to change the default binary filename = \"dictionary.bin\"", {"dictionary"});
    args::Flag histogram(imgproc, "histogram", "Get the histogram descriptor used for clasification. By default the dictionary will be calculate for this step. to use an existing \
                                      dictionary file use the -l argument. Use the -s argument to change the default binary filename = \"histogram.bin\"",  {"histogram"});
    
    args::Group arguments(imgproc, "ARGUMENTS");
    args::ValueFlag<std::string> load(arguments, "file.bin", "name of binary file to load (with .bin)", {'l'});
    args::ValueFlag<std::string> save(arguments, "file", "name of binary file to save data (with .bin), no file will be saved by default", {'s'});
    args::ValueFlag<std::tuple<int, int, int>> n_img(arguments, "Integer", "Number of images to use for each set. For --dictionary command must specify start_index, final_index", {'n'});
   
    args::Group km(arguments, "(Optional) Modify the parameters of K-means algorithm. this options is only for dictionary step.", args::Group::Validators::DontCare);
    args::ValueFlag<int> kmeans(km, "Criteria", "Stop criteria for K-means clustering (1 for iteration, 2 for epsilon, 3 both)[If set mus specify all the K-means criteria parameters].", {'k'});
    args::ValueFlag<int> it(km, "Integer", "Iteration numbers for K-means clustering (0 if not used).", {'i'});
    args::ValueFlag<int> a(km, "Integer", "Attempt number for K-means clustering (0 if not used).", {'a'});
    args::ValueFlag<float> e(km, "Float", "epsilon: distance theshold (0 if not used).", {'e'});

    args::Group svm(p, "SVM COMMANDS");
    //args::Flag problem(svm, "svm-problem", "Construct the file for train the SVM.",{"problem"});
    //args::Flag grid(svm, "svm-grid", "optimize the C ang gamma parameters using an logarithmic grid search with 4-fold cross validation in the {-5,5} interval.",{"grid"});
    //args::Flag train(svm, "svm-train", "train the SVM. By default Radial Basis Functionkernel will be used.",{"train"});
    //args::Flag predict(svm, "svm-predict", "Predict labels of the test file.",{"predict"});
    args::ValueFlag<std::string> externalsvm(svm, "file", "Generate a txt problem file to use with external libsvm. specify the input histogram filename.bin,\
                                                   a svm-problem file will be generated.", {"problem"});
    //args::ValueFlag<std::string> prob(svm, "file", "Specify the problem file to train the SVM.", {'t'});
    //args::ValueFlag<std::string> model(svm, "file.model", "Specify the the model file generated by svm-train", {'m'});
    //args::ValueFlag<std::string> pred(svm, "file", "svm-predict will produce output in the output_file.", {'p'});
    //args::ValueFlag<std::string> test(svm, "file", "Specify the test data you want to predict.", {'d'});

    args::Positional<std::tuple<int, int, int> > year(parser, "YEARS", "years of set to work with (separate by commas)");
    valid_sets[1]=true;
    try{
        parser.ParseCLI(argc, argv);
        std::cout << std::endl;
    }
    catch (args::Help){
        std::cout << parser;
        return 0;
    }
    catch (args::ParseError e){
        std::cerr << e.what() << std::endl;
        std::cerr << parser;
        return 1;
    }
    catch (args::ValidationError e){
        if(!descriptor || !dictionary || !histogram)
            std::cerr << "Select at most one command" << std::endl;
        if(kmeans)
            std::cerr << "Select all the Kmeans parameters" << std::endl;
        std::cerr << parser;
        return 1;
    }
    if (year){
        std::vector<int> get_years;
        bool yr_check=false;
        
        get_years.push_back(std::get<0>(args::get(year)));
        get_years.push_back(std::get<1>(args::get(year)));
        get_years.push_back(std::get<2>(args::get(year)));
        for(i=0; i<3; i++){
            for(j=0; j<3; j++){
                if( get_years.at(j) == years[i] ){
                    valid_sets[i]=true;
                    break;
                }
            }
        }
        for(i=0; i<3; i++)
            if(valid_sets[i])
                std::cout << "Valid Set: " << years[i] << std::endl;
    }
    if(1){//n_img){
        std::vector<int> get_nimages;
        
        get_nimages.push_back(0);//std::get<0>(args::get(n_img)));
        get_nimages.push_back(2);//std::get<1>(args::get(n_img)));
        get_nimages.push_back(0);//std::get<2>(args::get(n_img)));
        n=0;
        if(dictionary){
            start_index = get_nimages.at(0);
            final_index = get_nimages.at(1);
            n_images = start_index - final_index;
        }
        else{
            for(i=0;i<3;i++){
                if(valid_sets[i]){
                    n_imgs[i]=get_nimages.at(n++);
                    n_images+=n_imgs[i];
                    std::cout << "Test set "<< years[i] <<" with " << n_imgs[i]<< " images" << std::endl;
                }
                else{
                    n_imgs[i]=0;
                }
            }
        }
        std::cout << "total images to use: "<< n_images <<std::endl;
    }else{
        for(i=0; i<3; i++){
            if(valid_sets[i]){
                n_images+=n_imgs[i];
                std::cout << "Test set "<< years[i] <<" with " << n_imgs[i]<< " images" << std::endl;
            }
        }
        if(n_images == 0)
            std::cout << "no set selected " <<std::endl;
        else
            std::cout << "total images to use: "<< n_images <<std::endl;
    }

    if (!load || histogram){
        // Read the filenames from default directory
        std::cout << "Reading filenames from  Vision_MCR directory" << std::endl;
        file_names = getFileNames(valid_sets, n_imgs);
        // Get the maximun Response Filter
        std::cout << "calculating  the Maximun Response Filter for: "<<n_images <<" images" << std::endl;
        imgs_MR = new cv::Mat[n_images];
        for(j=0; j<n_images ; j++){
            std::cout <<"[ " << porcentage(j, n_images) << " %]"<<std::flush<<"\r";
            imgs_MR[j] = getMaximumResponseFilter(file_names.at(j));
        }
        std::cout << "[ " << porcentage(j, n_images) << " %]"<< std::endl;
    }
    if (1){//(descriptor || dictionary || histogram) && !load){
        descriptors = new struct img_data[n_images];
        std::cout << "Calculating texture descriptor for: "<< n_images << " images" << std::endl;

        // Get the texture descriptor for selected images
        int j, k, n=0;
        int index_data=0;
        for(k=0; k<3; k++){
            if(valid_sets[k]){
                for(j=0; j<n_images ; j++){
                    std::cout << "Set:" <<years[k]<<" [" + std::to_string(porcentage(n+1, n_imgs[k])) + '%' + "] "+ file_names.at(n)<<std::flush<<"\r";
                    descriptors[n] = getDescriptor(file_names.at(n)+".txt", imgs_MR[n], years[k],n);
                    n++;
                }
            }
        }
        std::cout <<std::endl;
        // Save the Maximum Response Filter information in a binary file
        if(save && descriptor){
            savefile = args::get(save);
            saveDescriptor(descriptors, n_images,  savefile );
            std::cout << "saved Descriptor in  "<< "\"" <<  savefile << "\"" << std::endl;
        }
        else if(!save && descriptor){
            saveDescriptor(descriptors, n_images, "descriptor.bin");
            std::cout << "saved Descriptor in  "<< "descriptor.bin" << std::endl;
        }
        // Deleting the names of the set
        file_names.erase(file_names.begin(), file_names.end());
    }
    
    if(1){//dictionary){
        cv::Mat dictionaryTextons(135, 24, CV_32FC1);
        if(load){
            // Load the image data from a binary file
            loadfile = args::get(load);
            std::cout << "Loading descriptor: "<< "\""<< loadfile << "\"" << std::endl;
            descriptors = loadDescriptor(n_images, loadfile);
        }
        start_index =0;
        finish_index =n_images;
        // Obtaining the textons from a group of images of the data
        std::cout << "Calculating the texture elements "<<  std::endl;
        getDictionaryTextons(dictionaryTextons, descriptors, start_index, finish_index);
        
        // Save the Maximum Response Filter information in a binary file
        if(save){
            saveDictionaryTextons(dictionaryTextons, args::get(save));  
            std::cout << "saved Dictionary in  "<<  args::get(save) << std::endl;
        }
        else if(!save){
            saveDictionaryTextons(dictionaryTextons, "dictionary.bin");  
            std::cout << "saved Dictionary in  "<<  "dictionary.bin" << std::endl;
        }
    }
    if(histogram){
        cv::Mat dictionaryTextons(135, 24, CV_32FC1);
        descriptorsH = new struct img_dataHistogram[n_images];
        if(load){
            // Load the image data from a binary file
            loadDictionaryTextons(dictionaryTextons, args::get(load));
            std::cout << "Dictionary of texture elemets Loaded: "<< "\"" <<args::get(load) << "\""<<std::endl;
        }
        else{
            std::cout << "Calculating the dictionary of texture elements "<<  std::endl;
            // Obtaining the dictionary of textons from a group of images of the data
            getDictionaryTextons(dictionaryTextons, descriptors, start_index, finish_index);
        }
        n=0;
        for(k=0; k<3; k++){
            if(valid_sets[k]){
                std::cout <<"Set: "<<years[k]<<std::endl; 
                for(j = 0; j<n_images; j++){
                    std::cout << "[ " << porcentage(n,n_images) << " %]" << std::flush << "\r";
                    descriptorsH[n] = getHistogramDescriptor(file_names.at(j)+".txt", imgs_MR[j], dictionaryTextons, years[k], n);
                    n++;
                }
                std::cout << "[ " << 100 << " %]" << std::flush << std::endl;
            }
        }
        // Deleting the names of the set
        file_names.erase(file_names.begin(), file_names.end());
        savefile = "histogram.bin";
        if(save && histogram){
            // Save the Maximum Response Filter information in a binary file
            savefile = args::get(save);
            
        }
        saveDescriptorH(descriptorsH, n_images, savefile);
        std::cout << "Saved histogram descriptor in  "<<  savefile << std::endl;  
    }
    

    if(externalsvm){
        loadfile = args::get(externalsvm); 

        std::cout << "Obtaining the structure problem file from: "<<  loadfile << std::endl;
        descriptorsH = loadDescriptorH(2, loadfile);
        
        // Creating the SVM structures
        saveSVMtxt(descriptorsH);
    }

    
    /*if(prob){
        
        //CODIGO PARA OBTENER EL SVM-PROBLEM
        
    }
    if(grid){
        
       // CODIGO PARA OBTENER EL MEJOR C Y GAMMA
        
    }
    if(model){
        
        //CODIGO PARA OBTENER EL ARCHIVO.MODEL (ENTRENAR SVM)
        
    }
    if(test){
        
        // PARA SELECCIONAR EL ARCHIVO A PROBAR
        
    }*/
/*
    struct svm_problem prob;
    struct svm_parameter param;
    struct svm_model *model;
    const char *error_msg;

    getProblemSVM(&prob, descriptorsH, 100, 0, 0);
    //bestParametersSVM(prob, param);
    
    getParamSVM(&param, exp2(-1), exp2(-2));

    error_msg = svm_check_parameter(&prob, &param);
    if(error_msg){
		fprintf(stderr,"ERROR: %s\n",error_msg);
		exit(1);
	}
    
    model = svm_train(&prob, &param);
    
*/
    // Freeing space for used arrays
    delete [] descriptors;
    delete [] descriptorsH;
   // delete [] imgs_MR;
    return 0;
}
